## 💡 들어가며 💡

지난 시간에 우리는 재귀에 대해서 배웠습니다. 이번 시간에는 재귀에 이어서 자주 쓰이는 알고리즘인 `탐색 혹은 검색(Search)`에 대해서 배워보고자 합니다.

정말 많이 쓰이고, 다양한 종류가 있지만, 우리는 `이진 탐색(Binary Search)`에 집중해서 살펴보고자 합니다.

그러면 한번 같이 알아볼까요?

### 🚀 염두에 둘 사항 🚀

본격적인 학습에 들어가기에 앞서서 먼저 한가지를 명확히 하고 넘어가는게 좋을 듯 합니다.

저희가 다루는 컴퓨터 세계의 언어는 `영어(English)`에 기반하고 있습니다.
C, C++, Python, JS 등에 상관 없이 작성하다보면 느끼겠지만, 결국 작성하는 언어는 영어입니다. 이를 어떻게 약속해서 표현하느냐에 차이가 있을 뿐이지요.

이는 프로그래밍 언어에만 국한된 것이 아닙니다.

컴퓨터와 관련된 모든 내용이 사실상 영어라는 언어에 기반을 하고 있습니다.
사용하는 용어들도 마찬가지이지요.

그렇지만, 저희는 영어가 제 1 국어가 아닙니다. 한국어가 모국어이죠. 그렇다보니, 기본적으로 해당 내용들을 번역해서 접하게 됩니다.

다만, 영어를 배웠다면 아시겠지만 영어 표현을 우리말로 그대로 옮기기란 매우 어렵습니다. 그래서 진짜 번역을 잘하면 초월번역이다라는 표현을 쓰면서 칭송하는 것이지요.
정말 잘 된 번역이 극소수이기 때문에 그렇습니다.

지금 배울 `Search`알고리즘도 마찬가지입니다. 검색이라고 표현할 수도 있고, 탐색이라고 표현할 수도 있습니다.
우리말에서는 두 말이 조금 다른 뉘양스로 쓰입니다. 영어에서도 둘은 다르게 표현이 됩니다. 당장 한글을 영어로 검색하면 아래와 같이 나오네요.

> - 검색 : Searching
> - 탐색 : Exploration, Investigation

이처럼 뜻이 아예 다른 경우가 많습니다.

다만, 사용 용법에 따라서 `Search`를 검색으로도, 탐색으로도 번역을 하는 것이지요.

이를 염두에 둡시다. 한국어로 표현된게 정확한 표현이 아닐 수 있다는 것을요. 그렇기에 우리말로 표현하는 것과 괴리가 있을 수 밖에 없다는 것을요.

이는 앞에서 설명한 알고리즘도 그렇고 뒤에 설명할 내용도 그렇고, 모두 통용되는 부분이기에 가급적이면 영어로 용어를 기억하시는게 좋습니다.

슬라이딩 윈도우 기법 같은 경우 한국어로 표현하기 애매하잖아요? 그쵸?
한글로 작성하는 문서이다보니, 한국어 표현을 사용하긴 하겠지만 본 챕터에서도 검색, 탐색을 왔다갔다 하면서 표현할 예정입니다. 그렇기에 만약 어색하게 느껴지신다면 영어로 치환해서 Search로 읽어주시면
감사하겠습니다!

그러면 다시 들어가봅시다!

## 💡 탐색 알고리즘 💡

### 🚀 탐색이란 무엇인가? 🚀

`Search`라고 하면 무엇이 떠오르시나요?

![[img020.png]](img/img020.png)

![[img021.png]](img/img021.png)

저는 위와 같은 검색창이 떠오릅니다.

이를 영어로 `Search bar`라고 하는데, 지금부터 배울 탐색도 이와 유사한 개념입니다.
여러가지 데이터 덩어리에서 무언가를 찾는 것이지요.

사실 일상에서 너무 자주 쓰는 표현이기 때문에, 이게 무엇인지 이해하는데는 크게 어려움이 없을 것이라고 생각합니다.

그래서 지금부터는 조금 다른 이야기를 해보고자 합니다.

### 🚀 왜 탐색이 중요한가? 🚀

탐색이 왜 필요하는지는 다들 알 것이라 생각되어서 설명은 생략하겠습니다.

사실 컴퓨터 세상에서 탐색은 굉장히 중요하게 여겨집니다. 왜 그럴까요? 한번 생각해보신 적이 있나요?

컴퓨터는 0과 1을 기반으로 하는 2진법을 다루는 기계장치입니다. 저희가 보는 그래픽적인 화면이나 프로그램들 모두 0과 1로 이루어진 수들을 컴퓨터가 굉장히 빠른 속도로 계산해서 동작시키는 것이지요.
컴퓨터가 처음 등장한 이래, 컴퓨터가 다루는 데이터는 굉장히 커져만 갔습니다.

그래서 지금은 AI와 함께 빅데이터, 데이터마이닝 등을 이야기하면서 상상할 수도 없는 엄청 큰 데이터를 이야기하고 있죠.

사실 데이터가 한 두개일때는 검색이 필요하지 않습니다. 그냥 처음부터 순회해서 찾으면 금방 원하는 것을 찾을 수 있으니까요.

그렇지만, 빅데이터를 논하는 지금은 이런 탐색 자체가 굉장히 중요하게 되었습니다. 처음부터 하나씩 살펴볼 경우에, 만약 찾고자 하는 데이터가 끝에 있다고 하면  `O(N)`의 시간복잡도가 요구될텐데, 데이터가
수천억개라면...?
천억, 조, 경 등등 어마어마하게 커진다면? 그에 대한 검색시간 역시 막대하게 늘어날 것입니다.

실시간 처리를 해야하는 상황이라면 이런 요소들은 결국 렉이나 딜레이로 이어질 것이고, 사용자 경험에 치명적으로 작용하겠죠.

그래서 똑똑한 연구자들은 탐색의 중요성을 인지한 이래로 많은 알고리즘을 고안해냈습니다.

### 🚀 다양한 탐색 알고리즘 🚀

![[img022.png]](img/img022.png)

나무위키에서 탐색 알고리즘을 검색했을 때 나온 알고리즘 분류입니다. 문제에 따른 전략이 표시되어 있고, 해당 전략을 구현하는 방안은 정말 많습니다.

이처럼 탐색 알고리즘은 정말 다양하게 존재하고 있습니다.

저희는 이 모든 알고리즘을 다루지 않고, 꼭 알아야하는 `이진 탐색(Binary Search)`에 대해서 다루고자 합니다.
이는 이후에 이야기할 `이진탐색트리(Binary Search Tree)`나 여타 알고리즘에서 핵심적으로 작용하는 부분이기에, 꼭 알고 넘어가야하는 이진 탐색 만을 다루고자 합니다.

물론 여기까지 가기 위해서 제일 간단한 탐색 알고리즘도 살펴볼 것이지만요.

## 💡 알고리즘 관점의 탐색 💡

### 🚀 문제를 통해 살펴보기 🚀

탐색이라는 개념은 알고 있으니, 이를 어떻게 구현할 것인지 이야기를 해봅시다.

여기서 잠깐, 이진 탐색은 잠깐 뒤로 미뤄둡시다. 그냥 순수하게 탐색을 어떻게 프로그램으로 구현할 것인지에 대해서 이야기를 해보고자 합니다.

지난 재귀때에도 그랬지만, 구현을 살펴보는 데 제일 빠른 방법은 수식으로 표현해서 코드로 옮기거나, 예제를 통해서 직접 해보면서 느끼는 것입니다.
이번 탐색의 경우에는 문제를 직접 풀어보면서 확인해보고자 합니다.

> Q. 문제 1
>
> 문자 배열 ['b', 'c', 'a', 'd', 'g', 'f'] 가 있다. 여기서 문자 d의 인덱스를 찾아 반환하는 함수를 작성하시오. 없을 경우 -1을 반환하시오.

위와 같은 문제가 있다고 해봅시다.

한번 풀어보시겠어요?
항상 제가 강조하는 부분이 있죠? 의사코드는 반드시 같이 작성해주세요!

### 🚀 문제 풀이 🚀

#### 의사코드

```pseudocode
1. 문자 배열과 찾고자하는 문자를 인풋으로 받는 함수 searchWord를 선언한다.
2. 문자 배열의 처음부터 끝까지 순회한다. (반복 변수 : i, 이는 0으로 초기화한다.)
	2-1. 순회하면서 문자를 찾으면 해당 인덱스를 반환한다.
3. 찾고자하는 문자가 없으므로, -1을 반환한다.
```

저는 위와 같이 의사코드를 작성해볼 수 있을 것 같아요.
또한, 자바스크립트 코드로 작성하면 아래와 같이 표현할 수 있을 것 같아요.

#### 코드

```javascript
function searchWord(arr, word) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === word) return i;
  }
  return -1;
}
```

위와 같이 표현하셨다면, 축하드립니다! 🎉 여러분은 탐색이 뭔지 알고, 이를 표현할 수 있으신 겁니다.

탐색은 위처럼 어떤 배열이나 문자열, 혹은 숫자열 등의 데이터 집합에서 특정한 조건에 맞는 요소를 찾아내는 모든 과정을 의미합니다.

위처럼 푸는 방식을 Naive하게 푼 탐색 알고리즘 문제라고 합니다.

`naive`는 순진해빠진 이라는 뜻으로 굉장히 단순하게 풀었다 정도로 표현할 수 있들 듯 합니다.
그렇지만, 어찌되었든 이런류의 문제를 풀 수 있게 되었다는 것이죠.

### 🚀 단순한 탐색의 문제점 🚀

이제 위와 같은 방식으로 아래의 문제도 풀어보시겠어요?

> Q. 문제 2
>
> 1부터 1,000,000,000,000 까지의 수가 담긴 배열이 있다. 여기서 1,000,000,000,001 의 인덱스를 찾아 반환하라. 만약 없을 경우에는 -1을 반환하라.

풀어보셨나요?

코드 작성은 앞서서 푼 문제 1과 유사하게 나올 거에요.
단순하게 풀린다는 의미이지요.

그렇지만 위 코드에는 심각한 문제점이 있어요.

시간 복잡도를 살펴볼까요?
단순한 반복이 이루어지므로, `O(N)`으로 표현이 됩니다.

즉, 최악의 경우에 주어지는 배열의 크기만큼 계속 시간이 늘어난다는 것이지요.

이는 탐색이 왜 중요한가에 대해서 이야기를 했을 때처럼 데이터가 커져가는 요즘 `O(N)`으로 나오는 시간 복잡도는 프로그램이 느려지게 하는 원인이 될 수 있습니다.

그래서 사람들은 이를 줄일 수 있는 방법이 없을까 하다가 한가지 알고리즘을 고안하게 됩니다.

## 💡이진 탐색(Binary Search) 💡

위의 문제점을 해결하고자, 조금 더 짧은 시간 내에 탐색을 할 수 없을까 해서 나온 방식이 이진 탐색입니다.

### 🚀 이진 탐색의 전제 🚀

잠깐, 이진 탐색에 대해 논하기 전에 알아두셔야 하는 사항이 있습니다.

이진 탐색은 오로지 `정렬되어 있는 (Sorted)` 자료에 대해서만 사용이 가능합니다.
무작위로 막 섞인 자료에는 사용이 안된다는 것이지요.

정렬되었다고 함은 [1,2,3,4,5] 혹은 [5,4,3,2,1] 과 같이 오름차순, 내림차순으로 되어 있는 것을 의미합니다.
[3,1,4,5,2] 와 같이 무작위로 배치되어 있는 요소에는 사용할 수 없다는 것을 기억해두세요.

### 🚀 실생활에 빗대어 이해하기 🚀

![[img023.jpg]](img/img023.png)
앞에서 다루었던 탐색을 다시한번 살펴봅시다.

책에서 어떤 페이지를 찾아야 한다고 했을 때, 제일 첫 페이지부터 한 장씩 해당 페이지에 도달할 때까지 넘겨보는 방식이 우리가 앞에서 다룬 방식입니다.

그러면 이진 탐색은 무엇일까요? 책을 대뜸 중간을 펼쳐보는 것입니다.
그리고 그 중간 페이지를 기준으로 찾아야 하는 페이지가 그보다 작은지 큰지를 비교해서 나머지 반절을 버리고 남은 반절을 살펴보는 것을 반복하는 작업이라과 할 수 있습니다.

난잡해서 다시 정리를 해서 표현하면 아래와 같이 표현할 수 있어요.

이진 탐색은 일련의 정렬된 항목들 사이에서 특정 항목을 빠르게 찾아내는 검색 기법이에요.

책의 색인을 찾는 과정을 일상생활에서의 예시로 들었죠.

예를 들어, 당신이 쿠킹북에서 '묵사발' 레시피를 찾고 싶다고 생각해봅시다. 책의 색인은 알파벳 순으로 정렬되어 있다고 가정을 합시다. (앞에서 말했죠? 이진 탐색은 정렬이 되어 있는 경우만 가능해요.)
그리고, 책의 제일 앞에는 감자탕이 적혀 있고, 제일 마지막에는 함박스테이크가 적혀있다고 가정해봅시다.
이진 탐색을 이용하여 레시피를 찾는 과정은 다음과 같아요:

1. **중앙 위치 확인**: 책의 중앙 부분을 엽니다. 만약 중앙의 색인이 '묵사발'보다 앞에 있다면(예를 들어 '너비아니'), '감자탕'과 '너비아니' 사이에 '묵사발'이 존재하지는 않을 것이기 때문에, 이를
   버리고 '너비아니'와 '함박스테이크' 사이를 나타내는 뒷부분을 살펴봐야합니다. 반대로, 펼친 페이지가 '묵사발'보다 뒤에 있다면(예를 들어 '피자'), 뒤에 부분을 버리고, '감자탕'과 '피자' 사이가 되는
   앞부분을 살펴봅니다.

2. **범위를 절반으로 줄이기**: 이제 선택한 범위(앞쪽 혹은 뒷쪽)의 중앙을 다시 확인합니다. 이 과정을 '묵사발'을 찾거나, 검색 범위가 더 이상 줄어들 수 없을 때까지 반복합니다.

3. **목표 발견**: 최종적으로 '묵사발'에 해당하는 페이지를 찾으면 검색을 종료합니다.

이와 같이 이진 탐색은 시작점을 중간으로 설정하고, 검색 범위를 점점 좁혀가면서 목표를 효율적으로 찾아가는 방식이 `이진 탐색(Binary Search)`입니다.

### 🚀 문제를 통해 구현을 살펴보기 🚀

개념은 좀 와 닿으시나요? 그러면 이제 문제를 통해서 어떻게 구현을 할 수 있는 지 알아볼까요?

> Q. 문제 3
>
> [1, 2, 3, 4, 5, 6, 7] 이라는 배열이 주어졌을 때, 3의 인덱스를 반환하는 함수를 작성하시오. 만약 없을 경우 -1을 반환하시오.

한번 풀어보시겠어요?

#### 의사코드

```pseudocode
1. 배열과 숫자를 인자로 하는 함수 binarySearch를 선언한다. 이때, 배열을 arr이라고 하고, 숫자를 num이라고 한다.
2. 배열의 길이 / 2 를 버림한 값을 mid에 저장한다.
3. 배열의 처음 인덱스인 0을 start에 저장하고, end에는 배열의 길이 -1 만큼을 저장한다.
4. arr[mid] !== num 이면서(and), start < end 인 경우 반복 한다
	4-1. 만약 arr[mid] > val 인 경우
		4-1-1. end = mid - 1 을 한다.
	4-2. else 인 경우,
		4-2-1. start = mid + 1 을 한다.
	4-3. mid에 (start + end) / 2 를 한 뒤 버림한 값을 저장한다.
5. arr[mid]가 num과 같으면 mid를 리턴하고 아니라면 -1을 리턴한다.
```

저는 위와 같이 의사코드를 표현할 수 있을 것 같아요.

코드로 표현하면 아래와 같이 표현할 수 있어요.

#### 코드

```javascript
function binarySearch(arr, num) {
  let start = 0;
  let end = arr.length - 1;
  let mid = Math.floor((start + end) / 2);

  while (arr[mid] !== num && start < end) {
    if (arr[mid] > num) end = mid - 1;
    else start = mid + 1;
    mid = Math.floor((start + end) / 2);
  }

  return arr[mid] === num ? mid : -1;
}
```

어떻게 이해가 되시나요?

이해가 안되어도 괜찮아요! 아래에서 천천히 살펴봐요!

### 🚀 그림으로 과정 살펴보기 🚀

![[img023.png]](img/img023.png)

![[img024.png]](img/img024.png)

![[img025.png]](img/img025.png)

![[img026.png]](img/img026.png)

![[img027.png]](img/img027.png)

![[img028.png]](img/img028.png)

![[img029.png]](img/img029.png)

![[img030.png]](img/img030.png)

![[img031.png]](img/img031.png)

![[img032.png]](img/img032.png)

앞선 과정을 그림으로 표현하면 위와 같습니다.

어때요 이해가 되시나요?

### 🚀 재귀를 사용한 표현 🚀

앞에서 재귀를 배울 때 모든 반복은 재귀로 표현할 수 있다고 했었습니다.

탐색 역시 마찬가지입니다. 재귀로 표현할 수 있습니다.

이에 대해서는 관련 레퍼런스가 많은 관계로 별도로 코드를 작성하지는 않을게요.

그래도 재귀랑 친해지기 위해서 한번 작성해보시겠어요?

## 💡 정리 💡

오늘은 탐색에 대해서 알아보았습니다.

어때요 이해가 되시나요?

항상 그렇듯 이제는 문제를 풀어볼 차례입니다.
다행히도 탐색과 관련된 문제는 많아서 몇 가지 추려보았습니다.

#### 완전 탐색

이진 탐색을 다루기 전에 다룬 탐색 문제입니다.
기본적인 개념인, 무식하게 전부 탐색하는 것은 같으나, 문제에 따라서 탐색에서 추가적인 스킬이 필요할 수 있습니다.
그래도 탐색과 친해지기에는 좋은 문제들을 묶어 놓은 듯 하여 링크를 첨부합니다.

https://school.programmers.co.kr/learn/courses/30/parts/12230

#### 이진 탐색

이지 탐색과 관련된 문제입니다.

https://school.programmers.co.kr/learn/courses/30/parts/12486

한번 풀어보시면 좋을 것 같아요!

그러면 다음 시간에 정렬로 뵙겠습니다!